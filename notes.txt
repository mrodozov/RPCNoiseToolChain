 Separate responsibilities between different classes (objects) like :
  
- Basic requirements manager (RequrementsManager)
  takes care of initial system requirements as setting env vars 
  and checking tunnels 
  
- A run number manager (RunlistManager.py) 
  takes care of runlists to be collected, and waits until the execution is done to take 
  care file with the runs.
  Also it may take care of new data availability, to subscribe to the runregistry
  and wait for events such as new available runs. 
  
- Execution manager (RunProcessManager)
  Takes care of producing analysis. Executes C++, Python, ROOT macroses
  Each execution is independent from the rest on idea, but instead they have 
  requirements to be executed, for example if a given file taken as input by given
  module exists or not. The execution manager is kind of controller that should be able
  to spawn concurent threads taking into account the number of
  cores. Should also collect logs for errors etc.
  -- Write python class with methods to cary specific jobs, prepare HTML for example, or reformat something
     The execution manager would use objects


- An output manager (done in Chain and CommandClasses)
  this should take care of all of the outputs, validation, DB upload, data formats.
  Every secondary product, like preformatting existing output is done here, instead
  by the executable or scripts as before.
  Another thing would be methods that provides backward compatibility with the old
  formats, or to produce the old format from the new one if any format got changed,
  without keeping the old output. Collect logs for errors and completion
  
- Report manager (ReportService)
  Takes care of collecting error or success outputs, update the logs and send email
  notifications. Maybe method to create short reports from the log files

-

- Get the runregistry API to work from outside CERN

  1. Modify the RRApi class like this:
  1.1 import socks (pip install PySocks if the module not available)
  1.2 Change urllib -> urllib2 in rrapi.py (everywhere, uses with the import)
  1.3 Add third argument for RRApi class constructor and another member variable:
      def __init__(self, url, debug = False, use_proxy = False)
          self.use_proxy = use_proxy
        ....
  1.4 Add this:
      if self.use_proxy: socks.wrapmodule(urllib2)
      right before this:
      resp = urllib2.urlopen(callurl, sdata)
      in the get() method of RRApi class
  2. Setup socks proxy to lxplus like this:
      ssh -f -D 1080 -N lxplus.cern.ch -l yourusername
  3. Setup the default proxy settings in the python program
      socks.setdefaultproxy(socks.PROXY_TYPE_SOCKS5, '127.0.0.1', 1080)
    and when creating new RRApi object, just set the third argument in the constructor to 'True'
      rr_api = RRApi(URL, debug = True, use_proxy = True)
  ---------------------
  Enjoy your RR queries